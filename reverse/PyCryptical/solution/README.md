# Cryptic Code Conundrum Write-Up:
Connecting to the netcat server, you'll be prompted by an encrypted passphrase, and an encryption key (which regenerates every time you connect to the server).

Executing the `file` command on the given file, will give the following output: 
```
$file chall.pyc
chall.pyc: python 2.7 byte-compiled
```
PyC files (Python compiled files), are binary files generated by the Python interpreter when you import a Python source file. When a Python source file (with a .py extension) is executed, the interpreter compiles the source code into intermediate bytecode. This bytecode is then stored in a PyC file with a .pyc extension. PyC files are used to speed up the execution of Python programs (you can think of it like a cache) because the interpreter can directly execute the bytecode without the need to recompile the source code every time the program is run.

Googling around, you'll find that PyC files can be decompiled using Uncompyle6, we install it using pip:
```
pip install uncompyle6
```
Run uncompyle6 on the given .pyc file, and you'll get the source code of the challenge:
```
$uncompyle6 chall.pyc > chall.py
```
Now that we have the source of the challenge, we can try to reverse the encryption algorithm:

```python
def encrypt(plain_string, key):
    encrypted = []
    for i in range(len(plain_string)):
        encrypted_char = (ord(plain_string[i]) * ord(key[i % len(key)]) + pow(i,16))
        encrypted.append(encrypted_char)
    return encrypted
```
As you can see, it performs a simple encryption mechanism on every character of the passphrase, by multiplying its unicode code point (ord) with that of the following expression `key[i % len(key)]`, and then adds `pow(i,16)` to it.
So we can reverse this by simply substracting `pow(i,16)` from the encrypted character, and then dividing the result by `ord(key[i % len(key)])`
Here's the solving script:
```python
#!/usr/bin/python2
def decrypt(cyphertext, key):
    decrypted = []
    for i in range(len(cyphertext)):
        decrypted_char = chr((cyphertext[i] - pow(i,16)) // ord(key[i % len(key)]))
        decrypted.append(decrypted_char)
    return ''.join(decrypted)

if __name__ == "__main__":
    key = 'FhvHOspUHo'
    encrypted_flag = [5740, 5305, 79460, 43053993, 4294976302, 152587903850, 2821109913168, 33232930577676, 281474976716200, 1853020188865272, 10000000000006650, 45949729863579025, 184884258895042434, 665416609183187617, 2177953337809374928, 6568408355712904195, 18446744073709557328L, 48661191875666876981L, 121439531096594258616L, 288441413567621178226L, 655360000000000007980L, 1430568690241985333625L, 3011361496339065157220L, 6132610415680998656233L, 12116574790945106565454L, 23283064365386962896720L, 43608742899428874071088L]
    print(decrypt(encrypted_flag,key))
```
(You can decrypt it using python3 if you'd like to, and remove the `L` suffix)
## Passphrase:
```
$python2 solve.py 
R3vers3_My_B3l0v3d__r3veR5e
```
We enter the passphrase, and we get the flag.
## Flag:
`shellmates{Cr4ck3D_PyC_As_4_5harP_p1k3}`
