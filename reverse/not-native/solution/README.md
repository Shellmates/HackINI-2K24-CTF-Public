# Analzying the app
- An APK is given which means an android app
- APK files are known that are just archives and we can extract what there's inside using tools like `7z` or `unzip`
- Knowing what was used to develop the app will be helpful so we'll look for any indicators
- After searching we'll find that there's a special file `index.android.bundle` inside `res` folder which is a special file to React Native apps
- By looking at its type it contains JavaScript bytecode generated by `Hermes` engine
```bash
>>> file index.android.bundle 
index.android.bundle: Hermes JavaScript bytecode, version 94
```

# Solution
- By searching in the internet for Hermers bytecode decompilers there's one named `hermes-dec` which can be found via this [Link](https://github.com/P1sec/hermes-dec)
- After decompoling it using the previous tool we'll find an interesting part of code at the end
```js
        r2['checkFlag'] = r0;
        r1 = function(a0) { // Original name: checkFlag, environment: r1
            r2 = a0;
            r1 = r2.split;
            r0 = '';
            r2 = r1.bind(r2)(r0);
            r1 = r2.map;
            r0 = function(a0, a1) { // Environment: r0
                _fun5207: for(var _fun5207_ip = 0; ; ) switch(_fun5207_ip) {
case 0:
                    r3 = a0;
                    r1 = a1;
                    r0 = 2;
                    r0 = r1 % r0;
                    r2 = 0;
                    if(!(r0 !== r2)) { _fun5207_ip = 38; continue _fun5207 }
case 19:
                    r0 = r3.charCodeAt;
                    r1 = r0.bind(r3)(r2);
                    r0 = 1;
                    r0 = r1 + r0;
                    _fun5207_ip = 55; continue _fun5207;
case 38:
                    r1 = r3.charCodeAt;
                    r2 = r1.bind(r3)(r2);
                    r1 = 1;
                    r0 = r2 - r1;
case 55:
                    return r0;
                }
            };
            r3 = r1.bind(r2)(r0);
            r0 = global;
            r4 = r0.JSON;
            r2 = r4.stringify;
            r1 = [114, 105, 100, 109, 107, 110, 96, 117, 100, 116, 122, 105, 50, 115, 108, 52, 52, 96, 51, 54, 94, 53, 94, 111, 50, 88, 94, 83, 50, 53, 98, 85, 94, 111, 51, 85, 48, 119, 50, 96, 50, 79, 102, 50, 109, 52, 124];
            r1 = r2.bind(r4)(r1);
            r2 = r0.JSON;
            r0 = r2.stringify;
            r0 = r0.bind(r2)(r3);
            r0 = r1 === r0;
            return r0;
        };
        r2['checkFlag'] = r1;
        return r0;
```
- Using something like ChatGPT will be useful to make it more readable by asking it to regenerate the function from the decompiled code
```js
function checkFlag(input) {
    var str = input.split('').map(function (char, index) {
        if (index % 2 === 0) {
            return char.charCodeAt(0) + 1;
        } else {
            return char.charCodeAt(0) - 1;
        }
    }).join('');

    var jsonString = JSON.stringify(str);

    var key = [114, 105, 100, 109, 107, 110, 96, 117, 100, 116, 122, 105, 50, 115, 108, 52, 52, 96, 51, 54, 94, 53, 94, 111, 50, 88, 94, 83, 50, 53, 98, 85, 94, 111, 51, 85, 48, 119, 50, 96, 50, 79, 102, 50, 109, 52, 124];
    var keyString = String.fromCharCode.apply(null, key);
    var keyJsonString = JSON.stringify(keyString);

    return jsonString === keyJsonString;
}
```
- Now it's more easy to reverse it, we see that it takes the ASCII number for each char and substract or add 1 depending if the index in odd or even

# Solve script
```python
a = [114, 105, 100, 109, 107, 110, 96, 117, 100, 116, 122, 105, 50, 115, 108, 52, 52, 96, 51, 54, 94, 53, 94, 111, 50, 88, 94, 83, 50, 53, 98, 85, 94, 111, 51, 85, 48, 119, 50, 96, 50, 79, 102, 50, 109, 52, 124]

flag = ""

for i in range(len(a)):
    if i % 2 == 0:
        flag += chr(a[i] + 1)
    else:
        flag += chr(a[i] - 1)

print(flag)
```

# Flag
> shellmates{h3rm35_45_4_n3W_R34cT_n4T1v3_3Ng1n3}