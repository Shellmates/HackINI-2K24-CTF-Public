# Challenge: e_is_0x10001

## Write-up

The given Flask app appears to implement a basic encryption service using RSA. There are two routes: one for encrypting arbitrary messages (`/encrypt_message`) and another for encrypting a secret flag (`/encrypt_flag`). The public modulus `n` is generated by multiplying two 1024-bit prime numbers `p` and `q`. The Euler's totient function (`phi`) is then computed based on these primes.

Observing the `/encrypt_flag` route, it becomes evident that the app expects a public exponent `e` greater than 1000. However, it's mentioned that obtaining the flag won't be easy.

Upon further analysis, it's clear that the `encrypt_flag` route uses the same modulus `n` for encryption. The interesting part is that the modulus and public exponent `e` are provided by the user. This hints at a potential vulnerability.

To exploit this, one can use the fact that two numbers are coprime if their greatest common divisor (GCD) is 1. Specifically, if `e1` and `e2` are coprime, there exist integers `x` and `y` such that `x * e1 + y * e2 = 1`. This is known as Bézout's identity.

Now, by providing two different exponents (`e1` and `e2`) to the `/encrypt_message` route, it's possible to calculate `x` and `y` using the Extended Euclidean Algorithm. Once `x` and `y` are determined, the following relationship holds: `C1^x * C2^y ≡ m^1 ≡ m (mod n)`.

This means that combining the two ciphertexts obtained from encrypting a message with `e1` and `e2` will result in the original message.

## Flag

`shellmates{pleAs3_leT_RSA_PuBL1c_key_$tAt1c_4Nd_Us3_iT_FoR_ALL_y0uR_Mes$4G3$}`
